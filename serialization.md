[Вопросы для собеседования](README.md)

# Сериализация
+ [Что такое _«сериализация»_?](#что-такое-сериализация)
+ [Опишите процесс сериализации/десериализации с использованием `Serializable`.](#Опишите-процесс-сериализациидесериализации-с-использованием-serializable)
+ [Как изменить стандартное поведение сериализации/десериализации?](#Как-изменить-стандартное-поведение-сериализациидесериализации)
+ [Как исключить поля из сериализации?](#Как-исключить-поля-из-сериализации)
+ [Что обозначает ключевое слово `transient`?](#Что-обозначает-ключевое-слово-transient)
+ [Какое влияние оказывают на сериализуемость модификаторы полей `static` и `final`](#Какое-влияние-оказывают-на-сериализуемость-модификаторы-полей-static-и-final)
+ [Как не допустить автоматическую сериализацию?](#Как-не-допустить-автоматическую-сериализацию)
+ [Как создать собственный протокол сериализации?](#Как-создать-собственный-протокол-сериализации)
+ [Какая роль поля `serialVersionUID` в сериализации?](#Какая-роль-поля-serialversionuid-в-сериализации)
+ [Когда стоит изменять значение поля `serialVersionUID`?](#Когда-стоит-изменять-значение-поля-serialversionuid)
+ [В чем проблема сериализации Singleton?](#В-чем-проблема-сериализации-singleton)
+ [Какие существуют способы контроля за значениями десериализованного объекта](#Какие-существуют-способы-контроля-за-значениями-десериализованного-объекта)
+ [Сколько методов у Serializable? Если нет метода, то какова цель интерфейса Serializable?](#сколько-методов-у-serializable-если-нет-метода-то-какова-цель-интерфейса-serializable)
+ [Что произойдет, если один из членов класса не реализует интерфейс Serializable?](#что-произойдет-если-один-из-членов-класса-не-реализует-интерфейс-serializable)
+ [Если класс является сериализуемым, а его суперкласс - нет, каково будет состояние переменных экземпляра, унаследованных от суперкласса после десериализации? ](#если-класс-является-сериализуемым-а-его-суперкласс---нет-каково-будет-состояние-переменных-экземпляра-унаследованных-от-суперкласса-после-десериализации)
+ [Предположим, суперкласс нового класса реализует интерфейс Serializable, как можно избежать сериализации нового класса?](#предположим-суперкласс-нового-класса-реализует-интерфейс-serializable-как-можно-избежать-сериализации-нового-класса)
+ [Какие методы используются в процессе сериализации и десериализации в Java?](#какие-методы-используются-в-процессе-сериализации-и-десериализации-в-java)
+ [Предположим, у вас есть класс, который вы сериализовали и сохранили, а затем изменили этот класс, чтобы добавить новое поле. Что произойдет, если вы десериализуете уже сериализованный объект?](#предположим-у-вас-есть-класс-который-вы-сериализовали-и-сохранили-а-затем-изменили-этот-класс-чтобы-добавить-новое-поле-что-произойдет-если-вы-десериализуете-уже-сериализованный-объект)
+ [Можем ли мы передать сериализованный объект через сеть?](#можем-ли-мы-передать-сериализованный-объект-через-сеть)
+ [Какие типы переменных не сериализуются во время сериализации Java?](#какие-типы-переменных-не-сериализуются-во-время-сериализации-java)

## Что такое _«сериализация»_?
__Сериализация (Serialization)__ - преобразования последовательность байтов для передачи по сети или сохранения. Сериализованные объекты можно затем десериализовать.

В Java, согласно спецификации Java Object Serialization существует два стандартных способа сериализации: стандартная сериализация, через использование интерфейса `java.io.Serializable` и «расширенная» сериализация - `java.io.Externalizable`.

Сериализация позволяет в определенных пределах изменять класс. Вот наиболее важные изменения, с которыми спецификация Java Object Serialization может справляться автоматически:

+ добавление в класс новых полей;
+ изменение полей из статических в нестатические;
+ изменение полей из транзитных в нетранзитные.

Обратные изменения (из нестатических полей в статические и из нетранзитных в транзитные) или удаление полей требуют определенной дополнительной обработки в зависимости от того, какая степень обратной совместимости необходима.

[к оглавлению](README.md#вопросы-для-собеседований-на-позицию-developer) [наверх](#Сериализация)

## Опишите процесс сериализации/десериализации с использованием `Serializable`.
При использовании Serializable применяется алгоритм сериализации, который с помощью рефлексии (Reflection API) выполняет:

+ запись в поток метаданных о классе, ассоциированном с объектом (имя класса, идентификатор `SerialVersionUID`, идентификаторы полей класса);
+ рекурсивную запись в поток описания суперклассов до класса `java.lang.Object` (не включительно);
+ запись примитивных значений полей сериализуемого экземпляра, начиная с полей самого верхнего суперкласса;
+ рекурсивную запись объектов, которые являются полями сериализуемого объекта.

При этом ранее сериализованные объекты повторно не сериализуются, что позволяет алгоритму корректно работать с циклическими ссылками.

Для выполнения десериализации под объект выделяется память, после чего его поля заполняются значениями из потока. Конструктор объекта при этом не вызывается. Однако при десериализации будет вызван конструктор без параметров родительского несериализуемого класса, а его отсутствие повлечёт ошибку десериализации.

[к оглавлению](README.md#вопросы-для-собеседований-на-позицию-developer) [наверх](#Сериализация)

## Как изменить стандартное поведение сериализации/десериализации?
+ Реализовать интерфейс `java.io.Externalizable`, который позволяет применение пользовательской логики сериализации. Способ сериализации и десериализации описывается в методах `writeExternal()` и `readExternal()`. Во время десериализации вызывается конструктор без параметров, а потом уже на созданном объекте вызывается метод `readExternal`.
+ Если у сериализуемого объекта реализован один из следующих методов, то механизм сериализации будет использовать его, а не метод по умолчанию :
    + `writeObject()` - запись объекта в поток;
    + `readObject()` - чтение объекта из потока;
    + `writeReplace()` - позволяет заменить себя экземпляром другого класса перед записью;
    + `readResolve()` - позволяет заменить на себя другой объект после чтения.

[к оглавлению](README.md#вопросы-для-собеседований-на-позицию-developer) [наверх](#Сериализация)

## Как исключить поля из сериализации?
С помощью ключевого слова `transient`, таким образом исключив поля из общего процесса сериализации (или с помощью `static`).

[к оглавлению](README.md#вопросы-для-собеседований-на-позицию-developer) [наверх](#Сериализация)

## Что обозначает ключевое слово `transient`?
Поля класса, помеченные модификатором `transient`, не сериализуются.

Обычно в таких полях хранится промежуточное состояние объекта, которое, к примеру, проще вычислить. Другой пример такого поля - ссылка на экземпляр объекта, который не требует сериализации или не может быть сериализован.

[к оглавлению](README.md#вопросы-для-собеседований-на-позицию-developer) [наверх](#Сериализация)

## Какое влияние оказывают на сериализуемость модификаторы полей `static` и `final`
static поля не сериализуются. Соответственно, после десериализации это поле значения не меняет. При использовании реализации `Externalizable` сериализовать и десериализовать статическое поле можно, но не рекомендуется, т.к. это может сопровождаться трудноуловимыми ошибками.

Поля с модификатором `final` сериализуются как и обычные. За одним исключением – их невозможно десериализовать при использовании `Externalizable`, поскольку `final` поля должны быть инициализированы в конструкторе, а после этого в `readExternal()` изменить значение этого поля будет невозможно. Соответственно, если необходимо сериализовать объект с `final` полем необходимо использовать только стандартную сериализацию.

[к оглавлению](README.md#вопросы-для-собеседований-на-позицию-developer) [наверх](#Сериализация)

## Как не допустить автоматическую сериализацию?
Чтобы не допустить автоматическую сериализацию можно переопределить `private` методы для создания исключительной ситуации `NotSerializableException`.

```java
private void writeObject(ObjectOutputStream out) throws IOException {
    throw new NotSerializableException();
}

private void readObject(ObjectInputStream in) throws IOException {
    throw new NotSerializableException();
}
```

Любая попытка записать или прочитать этот объект теперь приведет к возникновению исключительной ситуации.

[к оглавлению](README.md#вопросы-для-собеседований-на-позицию-developer) [наверх](#Сериализация)

## Как создать собственный протокол сериализации?
Для создания собственного протокола сериализации достаточно реализовать интерфейс `Externalizable`, который содержит два метода:

```java
public void writeExternal(ObjectOutput out) throws IOException;
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;
```

[к оглавлению](README.md#вопросы-для-собеседований-на-позицию-developer) [наверх](#Сериализация)

## Какая роль поля `serialVersionUID` в сериализации?
`serialVersionUID` используется для указания версии сериализованных данных.

Когда мы не объявляем `serialVersionUID`, среда выполнения Java делает это за нас, но этот процесс чувствителен ко многим метаданным класса включая количество полей, тип полей, модификаторы доступа полей, интерфейсов, которые реализованы в классе и пр.

Рекомендуется явно объявлять `serialVersionUID` т.к. при добавлении, удалении атрибутов класса динамически сгенерированное значение может измениться и в момент выполнения будет выброшено исключение `InvalidClassException`.

```java
private static final long serialVersionUID = 20161013L;
```
[к оглавлению](README.md#вопросы-для-собеседований-на-позицию-developer) [наверх](#Сериализация)

## Когда стоит изменять значение поля `serialVersionUID`?
`serialVersionUID` нужно изменять при внесении в класс несовместимых изменений, например при удалении какого-либо его атрибута.

[к оглавлению](README.md#вопросы-для-собеседований-на-позицию-developer) [наверх](#Сериализация)

## В чем проблема сериализации Singleton?
Проблема в том что после десериализации мы получим другой объект. Таким образом, сериализация дает возможность создать Singleton еще раз, что недопустимо. Существует два способа избежать этого:

+ явный запрет сериализации.
+ определение метода с сигнатурой `(default/public/private/protected/) Object readResolve() throws ObjectStreamException`, назначением которого станет возврат замещающего объекта вместо объекта, на котором он вызван.

[к оглавлению](README.md#вопросы-для-собеседований-на-позицию-developer) [наверх](#Сериализация)

## Какие существуют способы контроля за значениями десериализованного объекта
Если есть необходимость выполнения контроля за значениями десериализованного объекта, то можно использовать интерфейс `ObjectInputValidation` с переопределением метода `validateObject()`.

```java
// Если вызвать метод validateObject() после десериализации объекта, то будет вызвано исключение InvalidObjectException при значении возраста за пределами 39...60.
public class Person implements java.io.Serializable,
                               java.io.ObjectInputValidation {
    ...
    @Override
    public void validateObject() throws InvalidObjectException {
        if ((age < 39) || (age > 60))
            throw new InvalidObjectException("Invalid age");
    }
}
```

Так же существуют способы подписывания и шифрования, позволяющие убедиться, что данные не были изменены:

+ с помощью описания логики в `writeObject()` и `readObject()`.

+ поместить в оберточный класс `javax.crypto.SealedObject` и/или `java.security.SignedObject`. Данные классы являются сериализуемыми, поэтому при оборачивании объекта в `SealedObject` создается подобие «подарочной упаковки» вокруг исходного объекта. Для шифрования необходимо создать симметричный ключ, управление которым должно осуществляться отдельно. Аналогично, для проверки данных можно использовать класс `SignedObject`, для работы с которым также нужен симметричный ключ, управляемый отдельно.

[к оглавлению](README.md#вопросы-для-собеседований-на-позицию-developer) [наверх](#Сериализация)

## Сколько методов у Serializable? Если нет метода, то какова цель интерфейса Serializable?
Сериализуемый интерфейс существует в пакете java.io и составляет ядро механизма сериализации Java.  

Он не имеет никаких методов и также называется интерфейсом-маркером в Java. Когда ваш класс реализует интерфейс java.io.Serializable, он становится сериализуемым. 

[к оглавлению](README.md#вопросы-для-собеседований-на-позицию-developer) [наверх](#Сериализация)

## Что произойдет, если один из членов класса не реализует интерфейс Serializable?

Если вы попытаетесь сериализовать объект класса, который реализует Serializable, но объект включает ссылку на класс, не являющийся Serializable, тогда во время выполнения будет выброшено NotSerializableException

[к оглавлению](README.md#вопросы-для-собеседований-на-позицию-developer) [наверх](#Сериализация)

## Если класс является сериализуемым, а его суперкласс - нет, каково будет состояние переменных экземпляра, унаследованных от суперкласса после десериализации?

Процесс сериализации Java продолжается только в иерархии объектов до тех пор, пока класс реализует интерфейс Serializable, а значения переменных, унаследованных от суперкласса, будут инициализированы путем вызова конструктора несериализуемого суперкласса во время процесса десериализации.  

Как только цепочка конструкторов будет запущена, остановить это будет невозможно, поэтому даже если классы выше в иерархии (не) реализуют интерфейс Serializable (в оригинале, видимо, опечатка - прим.пер.), конструктор будет выполнен.

[к оглавлению](README.md#вопросы-для-собеседований-на-позицию-developer) [наверх](#Сериализация)

## Предположим, суперкласс нового класса реализует интерфейс Serializable, как можно избежать сериализации нового класса?

Если суперкласс класса уже реализует интерфейс Serializable в Java, то класс-наследник тоже является Serializable, поскольку вы не можете не реализовывать интерфейс родителя, и на самом деле невозможно сделать его классом Non Serializable.  

Однако, есть способ избежать сериализации для этого нового класса. Для этого вам необходимо реализовать методы writeObject() и readObject() и выбросить NotSerializableException из этих методов.

[к оглавлению](README.md#вопросы-для-собеседований-на-позицию-developer) [наверх](#Сериализация)

## Какие методы используются в процессе сериализации и десериализации в Java?

readObject(), writeObject(), readExternal() и writeExternal() или нет.  
Сериализация Java выполняется классом java.io.ObjectOutputStream. Этот класс представляет собой отфильтрованный поток, который обернут вокруг байтового потока нижнего уровня для обработки механизма сериализации.   
Чтобы сохранить любой объект с помощью механизма сериализации, мы вызываем ObjectOutputStream.writeObject(saveThisObject), а для десериализации этого объекта мы вызываем метод ObjectInputStream.readObject().  
Вызов метода writeObject() запускает процесс сериализации. Одна важная вещь, которую следует отметить в методе readObject(), заключается в том, что он используется для чтения байтов и для создания и возвращения объекта из этих байтов, который, в свою очередь, должен быть приведен к правильному типу.

[к оглавлению](README.md#вопросы-для-собеседований-на-позицию-developer) [наверх](#Сериализация)

## Предположим, у вас есть класс, который вы сериализовали и сохранили, а затем изменили этот класс, чтобы добавить новое поле. Что произойдет, если вы десериализуете уже сериализованный объект?

Это зависит от того, имеет ли класс собственный serialVersionUID или нет. Как мы знаем из вышеупомянутых вопросов, если мы не предоставим serialVersionUID в нашем коде, компилятор java сгенерирует его сам, и обычно он будет равен хеш-коду этого объекта. После добавления любого нового поля, есть вероятность, что новый serialVersionUID, сгенерированный для этой версии класса, не совпадает с уже сериализованным объектом, и в этом случае API выдаст исключение java.io.InvalidClassException. По этой причине рекомендуется иметь свой собственный serialVersionUID в коде, который всегда одинаков для одного класса.

[к оглавлению](README.md#вопросы-для-собеседований-на-позицию-developer) [наверх](#Сериализация)

## Можем ли мы передать сериализованный объект через сеть?

Да, вы можете передать сериализованный объект по сети, потому что сериализованный объект Java представляет собой набор байтов, которые могут быть переданы как угодно. Вы также можете сохранить сериализованный объект на диске или в базе данных как Blob.

[к оглавлению](README.md#вопросы-для-собеседований-на-позицию-developer) [наверх](#Сериализация)

## Какие типы переменных не сериализуются во время сериализации Java?

особенности сериализации static и transient переменных. Поскольку статические переменные принадлежат классу, а не объекту, они не являются частью состояния объекта, поэтому они не сохраняются во время процесса сериализации Java. Поскольку сериализация Java сохраняет только состояние объекта, а не сам объект, transient (временные) переменные также не включаются в процесс сериализации и не являются частью сериализованного состояния объекта.  

После этого вопроса, возможно, интервьюер спросит: если вы не храните значения этих переменных, то каким будет значение этих переменных после десериализации и воссоздания этого объекта?

При десериализации значения статических переменных не восстанавливаются из сериализованных данных. Вместо этого используются значения, которые были установлены в момент сериализации или значения по умолчанию, если они не были установлены.

Переменные, объявленные с ключевым словом transient, исключаются из процесса сериализации.  
При десериализации эти переменные получают значения по умолчанию для их типов.

[к оглавлению](README.md#вопросы-для-собеседований-на-позицию-developer) [наверх](#Сериализация)































# Источники
+ [IBM developerWorks](https://www.ibm.com/developerworks/ru/library/j-5things1/)
+ [Java-online.ru](http://java-online.ru/blog-serialization.xhtml)
+ [Изучите секреты Java Serialization API](http://ccfit.nsu.ru/~deviv/courses/oop/java_ser_rus.html)
+ [JavaRush](http://bit.ly/1xwRA2D)
+ [Записки трезвого практика](http://www.skipy.ru/technics/serialization.html)

[Вопросы для собеседования](README.md)